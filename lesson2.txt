Модель - объект,благодаря которому БД понимает,что необходимо создать новую таблицую.Более того, благодаря модели БД
понимает,какие поля в таблице необходимо создать,ибо в моделе не только перечисляются поля,но и указывается тип полей.

ВАЖНО!Все модели должны наследоваться от models.Model то встроенная в Django модель, которая связана с цепочкой действий
сохранения модели,внесения ее в миграцию,создание таблицы итд(то есть она является одним звеном в цепи работы моделей Django)

При создании моделей необходимо указывать тип поля.Поля могут быть
-короткими текстовыми CharField. В нем обязательно нужно указать макс длину поля -max_lenght
-обычное текстовое TextField
-целое числовое IntegerField
-нецелое FloatField
-файлы - FileField
-картинки ImageField
-логические - BooleanField

Также моделям присуще иметь дополнительные методы,например __str__
Этот метод будет отображать именно то,что в нем прописать во время вывода экземпляров модели

Цепочка действий после создания/изменения/удаления модели:
Методы за изменения не считаются,в этом случае не нужно
1)Создать миграцию,чтобы упаковать все изменения в файл миграции.Для этого необходимо написать команду:
py manage.py makemigrations
После выполнения этой команды будет создан файл миграции,который сохранится в каталоге migration  папке приложения
Удалять или модифицировать эти файлы нельзя!
2)Как только миграция была создана,можно написать команду,которая этот файл отправит в БД,чтобы изменения внеслись или
сохранились
py manage.py migrate
3)Необходимо зарегистрировать модель в админке,для этого в admin.py необходимо импортировать модель и прописать
следующее:
admin.site.register(Model)
Благодаря этому можно будет добавлять,изменять,удалять записи,при этом не отправляя SQL запросы самому.

! Благодаря моделям можно выводить записи с БД. В обычной ситуации это можно сделать через SQL запрос
Но Django обладает определенным механизмом вывода данных
ORM - механизм,работающий на основе python кода,который впоследствии генерируется в SQL запрос и
возвращает ответ в виде множества словарей(QuerySet)

QuerySet - коллекция записей,которая возвращается с запроса,где каждая запись упаковывается в словарь

Чаще всего после запроса объектов,их нужно отправить в шаблонизатор(html файл).Сделать это можно через контекст

Context - это механизм передачи данных,полученных с базы в шаблонизатор для последующего вывода на экран
Технически контекст это словарь. Благодаря этому можно впоследствии в шаблоне обратиться к ключу и получить значение(задачи)

После передачи контекста в шаблон необходимо вывести данные в определенном виде.В этом могут помочь шаблонные литералы
1){{ }}- для обычной вставки
2){% %} для циклов и условий
По факту эти литералы обрамляют пайтон код внутри html-страницы

Важным моментом является объявление циклов и условий.Из-за того что шаблон это html документ,все блоки должны иметь открывающую
и закрывающую частию
Например
{% for todo in todos %}
{{todo}}
{% endfor %}

Django также умеет работать со статическими файлами,такими как css,js,jpg итд. Но для корректной работы
необходимо указать директорию,в которой все эти файлы находятся,для этого нужно
1) Открыть settings.py и создать константу STATICFILES_DIRS со значением
(os.path.join(BASE_DIR, 'static')
таким образом к текущей директории проекта мы присоединяем директорию под названием static
ПОсле инициализации константы необходимо создать дтректорию на одном уровне с приложением
Теперь статические файлы можно использовать в приложении.Для этого необходимо в первой строке
шаблонизатора написать {% load static from static %}
тем самым подгружается вся папка со статическими файлами
Для того чтобы подключить css файлы необходимо написать
href = "{% static 'bulma.css' %}"

Любое взаимодействие с БД в Django происходит через запросы,которые могут быть сгенерированы или формой или ссылкой,
ибо форма сама по себе умеет отправлять запросы и ссылка тоже может ввести по указанному url
У формы есть атрибут method который может быть или POST или GET

Поэтому при создании механизма отправки в шаблонизаторе,важно придерживаться нескольких правил:
1) создать форму (или ссылку)
2) указать method
post для добавления/едактирования/удаления данных
get - для получения данных, для поиска,фильтрации итд
3)добавить csrf_token внутри формы
token - это подтверждение аутентификации пользователя. В django существвует два вида пользователя
авторизованный и анонимный
Обоим выдаётся токен для возможности отправки запроса.Этот токен обновляется вместе с сессией.
Сессия - промежуток времени,когда пользователь активен
Как только пользователь покидает веб приложение,через какое-то время сессия сбрасывается,будет выдан новый токен.
В клиентно-серверной архитектуре ни один запрос не может быть выполнен без показа токена,поэтому попытка отправки формы
без токена приведет к ошибке 401 - которая расшифровывается как "не авторизован или запросы запрещены"

csrf токен каждого пользователя хранится в cookies браузера, от которого был выполнен вход
Форма как и в HTML состоит из полей ввода. Для того чтобы можно было считать введенные данные с полей
необходимо каждому полю дать имя (атрибут name)


Форма отправляя запрос включает ORM Django
ORM - это мощный механизм,вкрученный в Django,который дает возможность разработчику делать SQL запросы с помощью
пайтон кода.
Например,чтобы получить все задачи с таблицы todos,достаточно написать:
select * from todos

Но в ORM достаточно написать
Todo.objects.all()

Или чтобы создать задачу,иначе говоря добавить новую в sql пишется
insert into todos values (id,todo_text,is_done)
Но в ORM:
Todo.objects.create(text='text', is_done=False)

Для правильной архитектуры веб приложения принято делить функционал на
разные виды. Например: главная страница отображается одной функцией,удаление второй,
редактирование третьей.
Как обычно, каждый вид должен иметь свой path, чтобы этот вид можно было вызвать

В приложении todos главная страница единственная.В ней будут происходить все манипуляции
Но для удобства необходимо разбить функционал на несколько задач,одна из которых удаление
Удаление,как и любой вид, требует нового маршрутизатора,в котором ожидается отправка уникальных данных задачи
Таким уникальным элементом чаще всего выступает pk
!Primary Key (первичный ключ) это ключ,которой выдается каждой записи для последующего обращения к нему.Такой ключ
всегда уникален и позволяется создавать связи между таблицами
Поэтому в маршрутизаторах можно написать следующее:
path('delete_todo/<int:pk>', views.delete_todo, name='delete_todo')
delete_todo/<int:pk> это пример ожидания динамических данных во время
отправки запроса на удаление
Это значит что запрос будет работать только тогда,когда отправляется pk задачи
Например localhost:8000/delete_todo/1 - это url запроса на удаление первой задачи
Но сам по себе запрос не будет отправлен.Удаление всегда будет происходить по нажатию соответствующей кнопки.
Это значит что триггером удаления является кнопка.Именно элемент кнопки должен генерировать запрос.
Поэтому кнопка по сути может быть ссылкой,которая замаскирована под кнопку
Для того чтобы сделать возможным генерацию запроса,необходимо в href прописать:
url - обозначает что это ссылка
app: обращение к приложению через его namespace
delete_todo - обращение к виду через его name
todo.pk - передача обязательного атрибута удаления в виде первичного ключа
Важно! Если маршрутизатор принимает динамические данные,то для этого должен существовать атрибут в функции
Пример
path('delete_todo/<int:pk>'
def delete_todo(request, pk)

Шаблонизаторы
Когда веб приложение разрастается до многостраничного сайта,то приходится дублировать
код,что противоречит принципу DRY. Решением в данном случае является использование layout
Это шаблон,в котором прописано всё что нужно всем страницам вебприложения
Именно в шаблоне прописывается код,который дублировался на странице
Зачастую шаблон имеет пустую часть,которая заполняется уже отдельными страницами
Открыть такую часть можно при помощи
{% block block_name %}
Например можно создать
{% block content %}
{% endblock %}
Далее, для использования шаблона,его необходимо импортировать с помощью
команды {% extends 'base_layout.html' %}
И по желанию заполнить пустую часть шаблона, раскрыв те же скобки
{% block content %}
{% endblock %}
и вписав между ними динамическую часть страницы

Редактирование объекта в Джанго происходит в 2 этапа:
1) Методом GET запроса показ текущей информации объекта
2) Сохранение новой информации в объект через POST запрос
Для дальнейшего изменения объекта его необходимо в первую очередь найти.
Как и с удалением, кнопка редактирования отправляет pk объекта, который необходимо отредактировать
Этот pk послужит ключом для поиска нужного объекта. Как только этот объект найден,
он может быть отправлен в шаблонизатор через контекст для показа его в поле ввода.
Это поле ввода должно быть внутри формы с методом post,
а также иметь атрибут value со значением переданного контекста
input type=text name=todo value={{ todo.text }}
После того как форму будет отправлена в виде отлавливается POST запрос и выводится
информация с формой
ВАЖНО!! При отправке get запроса формируется QueryDict c данными формы,а именно
1) csrfmiddlewaretoken -токен подтверждения личности
2) значение поля ввода. В качестве ключа берется название поля
(в нашем случае todo), а значением атрибута value становится значением ключа

Далее, во избежание ошибок, необходимо  произвести проверку определенности переменной,
в которой сохранена новая информация объекта
После этого можно записать запрос на редактирование
1 способ
Обратиться к полю объекта и присвоить новое значение
todo.text = new_text
После чего сохранить
todo.save()
Или используя filter и update сделать это в одну строку
Todo.objects.filter(pk=pk).update(text=new_text)
Оба варианта работают одинаково.
После этого в самом конце обязательно необходимо произвести перенаправление пользователя
ибо объект будет удален и Джанго выведет ошибку с текстом "Подходящий объект в БД не найден"

git - система контроля версий. Эта система,которая решает несколько проблем
1) Удаленное хранение кода
2) Работа команды с разных уголков мира
3) Контроль и модификация версий приложения
4) Портфолио
В основном код хранится в отдельном проекте,который инициализируется на github,такой проект называется
репозиторий. Репозиторий - это папка с проектом,которая выложена и сохранена в облаке.
С этого момента разработчик и его команда могут получить доступ для чтения или модификации кода.
Способы сохранения кода могут быть разными
В основном выделяют
1) локальная - сохранение кода на одном пк
2) централизованная - сохранение кода в отдельном централизованном компьютере,к которому все разрабы имеют доступ
3) распределенная хранение в отдельном репозитории и на компах всех разработчиков.
Проект на распределенной системе синхронизируется с репозиторием на ПК разработчиков
.github
Репозиторий, ветка, коммит, мерж, клонирование, пул реквест
Репозиторий это древо веток,в котором видны все изменения
Для того чтобы выложить проект на Гитхаб,необходимо в первую очередь проделать пару манипуляций
1) Скачать GIT
Как только GIT будет установлен,вместе с ним будет установлен Git bash, это командная строка,
в которой можно писать все команды для работы с системой контроля версий
По умолчанию это командная страка также устанавливается в командную строку ПК,
поэтому писать команды в Git можно и в обычном cmd.
2) Зарегистрироваться на git hub. Это  веб-приложение,которое работает на системе Git и дает возможность
удаленно в бесплатном облаке хранить код с проекта
3) Создать пустой репозиторий
4) Инициализировать репозиторий локально(на ПК) где хранится код проекта
Для этого есть команда git init
5) Создать файл .gitignore в котором записывается название файлов и директорий,
которые не должны попадать в облачный репозиторий
6) Собрать все изменения командой git add.Как только инициализирован пустой репозиторий
git будет следить за всеми изменениями кода относительно предыдущей версии. Все эти
изменения в дальнейшем можно увидеть командой git status